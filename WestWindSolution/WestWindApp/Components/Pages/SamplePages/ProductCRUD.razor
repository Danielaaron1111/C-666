@page "/productcrud/{productid:int?}"

<!--
    on the page directive above, a routing parameter has been add
        syntax: /routingname/{parametername:datatype}
    this will allow an integer value to be passed to this page
    the routing parameter (productid) needs to be declare in your code area below

    if you have the situation where your receive page may or may not receive a parameter
    value THEN make the datatype nullable (?)

    Exception

    if your routing parameter is a string, you do NOT need to specify the routing parameter datatype 
    HOWEVER 
        you will still want to place a ? (nullable) character at the end of the routing parameter name (eg {StringPkey?})
-->
<PageTitle>Product CRUD</PageTitle>
@rendermode InteractiveServer

<!-- Additional namespaces-->

@using WestWindSystem.BLL;
@using WestWindSystem.Entities;

<h1>Product CRUD</h1>
<cite> ... demonstrating CRUD using EditForm</cite>

<br />
<br />
@if (feedBackMsg.Length > 0)
{
    <div class="alert alert-info">
        <p>@feedBackMsg</p>
    </div>
}

@if (errorMsgs.Count > 0)
{
    <div class="alert alert-danger">
        <p>Please fix the following issues:</p>
        <ul>
            @foreach (var error in errorMsgs)
            {
                <li>@error</li>
            }
        </ul>
    </div>
}
<br />
<br />

<!-- EditForm

this groups a bunch of controls as a single form
allows for adding additonal options to integrate with your form controls
contains a set of enhanced input controls

register an EditContext instance for this form

DataAnnotationsValidator

the DataAnnotationsValidator component is used within an
EditForm to enable validation based on data annotations
        applied to model properties.

ValidationSummary

displays a list of all validation errors
show a summary of errors at the top of the form
errors can be from model properties or custom messages
this is optional

ValidationMessage

displays the message associated with the indicated entity field
this is optional

-->

<EditForm EditContext="editContext">
    <DataAnnotationsValidator/>
    <ValidationSummary/>

    <!--
        the form controls will appear between the start and end EditForm tags

        what about format layout
        you can use your normal formatting (eg bootstrap) in laying out your form
    -->
    <div class="row">
        <div class="offset-1 col-md-4">
            <label for="productid" class="form-label">Product ID</label>

            <!--
            We can use enhanced input type controls with EditForm
            No type attribute is need for the EditForm control, the type in
               is built into the control
            Binding parameter: bind-Value is required when using EditForm controls

            Since the pkey for Productid is an identity key, the user should not be
                able to alter the field. Use the attribute "readonly" to restrict data entry
            -->

            <InputNumber id="productid" class="form-control"
                        @bind-Value="currentProduct.ProductID"
                        style="width: 75px;" readonly/>
            <br/>
            <label for="productname" class="form-label">Name</label>
            <InputText id="productname" class="form-control"
                        @bind-Value="currentProduct.ProductName"/>
            <!--
                immediately after your input control you can add the validation
                    message tag IF you want your messages immediately after the control

                you can omit this control and still display an error message associated
                    with this control with the ValidationSummary
            -->
            <ValidationMessage For="@(() => currentProduct.ProductName)"/>
            <br/>
            <!-- Foreign Keys-->
            <!--
                foreign keys should be handled in a way that the contents
                    for selection is limited to the possible values on
                    the database
            -->
            <label for="categoryid" class="form-label">Category</label>
            <InputSelect id="categoryid" class="form-control"
                    @bind-Value="currentProduct.CategoryID">
                <option value="0">... select category ...</option>
                @foreach(var item in categoryList)
                {
                    <option value="@item.CategoryID">@item.CategoryName</option>
                }
            </InputSelect>
            <!--
                the validation messages that will appear in this control will
                    come from custom validation done within the event button method
            -->
            <ValidationMessage For="@(() => currentProduct.CategoryID)" />
            <br/>
            <label for="supplierid" class="form-label">Supplier</label>
            <InputSelect id="supplierid" class="form-control"
                         @bind-Value="currentProduct.SupplierID">
                <option value="0">... select supplier ...</option>
                @foreach (var item in supplierList)
                {
                    <option value="@item.SupplierID">@item.CompanyName</option>
                }
            </InputSelect>
            <ValidationMessage For="@(() => currentProduct.SupplierID)" />
            <br />
        </div>
        <div class="offset-1 col-md-4">
            <label for="qtyperunit" class="form-label">Qty / Unit</label>
            <InputText id="qtyperunit" class="form-control"
                       @bind-Value="currentProduct.QuantityPerUnit" />
            <ValidationMessage For="@(() => currentProduct.QuantityPerUnit)" />
            <br />
            <label for="minqty" class="form-label">Min Order Qty</label>
            <InputNumber id="minqty" class="form-control"
                         @bind-Value="currentProduct.MinimumOrderQuantity" />
            <ValidationMessage For="@(() => currentProduct.MinimumOrderQuantity)" />
            <br />
            <label for="unitprice" class="form-label">Unit Price</label>
            <InputNumber id="unitprice" class="form-control"
                         @bind-Value="FormatUnitPrice" />
            <ValidationMessage For="@(() => currentProduct.UnitPrice)" />
            <br />
            <label for="unitsonorder" class="form-label">Units on Order</label>
            <InputNumber id="unitsonorder" class="form-control"
                         @bind-Value="currentProduct.UnitsOnOrder" />
            <ValidationMessage For="@(() => currentProduct.UnitsOnOrder)" />
        </div>
    </div>
    <br/><br/>
    <div class="row">
        <div class="col-md-12 text-center">
            <button type="button" class="btn btn-outline-primary rounded-pill"
                    @onclick="OnCreate" style="width:160px;">
                Create
             </button>
             &nbsp;&nbsp;
            <button type="button" class="btn btn-outline-secondary rounded-pill"
                    @onclick="OnUpdate" style="width:160px;">
                Save
            </button>
            &nbsp;&nbsp;
           
            <button type="button" class="btn btn-outline-secondary rounded-pill"
            @onclick="OnDiscontinue" style="width:160px;">
                Discontinue
            </button>
          
            &nbsp;&nbsp;
            <button type="button" class="btn btn-outline-secondary rounded-pill"
                    @onclick="OnClear" style="width:160px;">
                Clear
            </button>
            &nbsp;&nbsp;
            <button type="button" class="btn btn-outline-secondary rounded-pill"
                    @onclick="OnGoToSearch" style="width:160px;">
                Search
            </button>
        </div>
    </div>


</EditForm>

@code {
    private string feedBackMsg = "";
    private List<string> errorMsgs = new();

    // EditForm properties and variables
    // will hold the instance of the data Model that is being maintained on the control
    private EditContext editContext;

    //will be used to place custom event validation messages into the same controls
    //  used by DataAnnotationsValidator
    private ValidationMessageStore validationMessageStore;

    //this is the instance of the entity Product that will hold the data of the form
    //this instance will be tied to the editContext
    private Product currentProduct = new();

    // foreign key fields
    [Inject]
    public CategoryServices _categoryServices{ get; set; }
    private List<Category> categoryList = new();

    [Inject]
    public SupplierServices _supplierServices{ get; set; }
    private List<Supplier> supplierList = new();

    [Inject]
    public ProductServices _productServices { get; set; }

    //this javascript injection is needed to used the continue dialogue prompt
    [Inject]
    public IJSRuntime jSRuntime { get; set; }

    [Inject]
    public NavigationManager navigationManager { get; set; }

    //parameter setup for receiving the incoming value
    //declare the routing parameter
    //this property needs a special annotation to indicate it is a parameter
    //parameter properties need to be accessible by other pages (aka classes)
    //  therefore they need to be public
    //IMPORTANT!!!! the datatype on the parameter declaration MUST match the
    //                  datatype on the page directive
    [Parameter]
    public int? productid { get; set; }

    //this property is used to format the UnitPrice to 2 decimal places
    //it is with this property that the data is extracted and set to the
    //      actual property in the product instance
    private decimal FormatUnitPrice
    {
        get { return Math.Round(currentProduct.UnitPrice, 2); }
        set { currentProduct.UnitPrice = value; }
    }

    protected override void OnInitialized()
    {
        base.OnInitialized();

        // .HasValue will test a nullable object to see if it has a underlying value of 
        //      the variable's datatype
        // here, if productid has a number then the condition is true
        if (productid.HasValue)
            //to access the value within a nullable object use the .Value property
            //  of the nullable object
            currentProduct = _productServices.Product_GetByProductID(productid.Value);


        //create the EditContext instance AND tie to the instance of the entity of the form
        editContext = new EditContext(currentProduct);

        //create validation MessageStore instance and indicate which EditContext it is
        //      associated with
        //needed for custom validation within the event code and
        //   allows the user to use the ValidationMesssage controls of the form
        validationMessageStore = new ValidationMessageStore(editContext);

        //fill the foreign key field collections
        categoryList = _categoryServices.Category_GetAll();
        supplierList = _supplierServices.Supplier_GetAll();
    }

    private void OnCreate()
    {
        //clear out old messages
        feedBackMsg = "";
        errorMsgs.Clear();
        validationMessageStore.Clear();

        try
        {
            // the first test is to check to see if there are ANY errors already
            // caught by the form using the DataAnnotationsValidator?
            if(editContext.Validate())
            {
                //no errors on the form at this time

                //if there are additional custom validation of your data
                //      you can still do that within the event coding

                //custom validation for this form will check to see if a category
                //   and supplier have been select (why: the list have a prompt that
                //   has a non valid sql foreign key value)

                //Problem:
                //CategoryID is an integer
                //the default of an integer is 0 ( a value)
                //NO foreign key/primary key on the database is 0

                //if a proper selection is not done, then when the
                //       record is attempted to be added to the the database
                //       the database will thrown an exception

                //Solution: custom validation
                if (currentProduct.CategoryID == 0)
                {
                    // construction of the validation message store command
                    //     .Add to your instance of the form for the indicated field
                    //parameter 1: the associated field to display the message
                    //               looking for the "field identifier"
                    //               use nameof(xxx) to supplier the
                    //               "field identifier"
                    //               example: editContext.Field(nameof(CurrentProduct.CategoryID))
                    //parameter 2: the message to display
                    //             example: "You must select a category"
                    validationMessageStore.Add(editContext.Field(nameof(currentProduct.CategoryID)),
                                                "You must select a category.");
                }
                if (currentProduct.SupplierID == 0)
                {
                    validationMessageStore.Add(editContext.Field(nameof(currentProduct.SupplierID)),
                                                "You must select a supplier.");
                }
                if(currentProduct.UnitPrice < 0.0m)
                {
                    validationMessageStore.Add(editContext.Field(nameof(currentProduct.UnitPrice)),
                                               "Unit price cannot be negative.");
                }

                //once your custom validation is done, if there was any, you can check to see
                //      what your validationMessageStore contains
                //if there are any new messages , indicate to the form that the store
                //      has been altered
                //to do this, we will use the Linq method .Any()  to determine if
                //      something exists
                //NOTE: the .Any() returns only a true or false; it does NOT return an actual records
                //      the .Where() returns actual record

                if(editContext.GetValidationMessages().Any())
                {
                    editContext.NotifyValidationStateChanged();
                }
                else
                {
                    //the program assumes that the data is clean and can be further processed

                    //call the product services to receive the "good" data
                    //      and add it to the database (CREATE!!!)
                    //call the appropriate service method and pass the current product instance
                    //      the service method will return the new (identity) primary key value.
                    int newProductId = _productServices.Product_Add(currentProduct);

                    //feedback to user on success
                    feedBackMsg=$"{currentProduct.ProductName} (ID:{newProductId}) has been added to file.";

                }
            }

        }
        catch(Exception ex)
        {
            feedBackMsg=$"System Error: {ex.Message}";
        }
    }

    private void OnUpdate()
    {
        //clear out old messages
        feedBackMsg = "";
        errorMsgs.Clear();
        validationMessageStore.Clear();

        try
        {
            if (editContext.Validate())
            {
                if (currentProduct.CategoryID == 0)
                {
                    validationMessageStore.Add(editContext.Field(nameof(currentProduct.CategoryID)),
                                                "You must select a category.");
                }
                if (currentProduct.SupplierID == 0)
                {
                    validationMessageStore.Add(editContext.Field(nameof(currentProduct.SupplierID)),
                                                "You must select a supplier.");
                }
                if (currentProduct.UnitPrice < 0.0m)
                {
                    validationMessageStore.Add(editContext.Field(nameof(currentProduct.UnitPrice)),
                                               "Unit price cannot be negative.");
                }

                if (editContext.GetValidationMessages().Any())
                {
                    editContext.NotifyValidationStateChanged();
                }
                else
                {
                    //the program assumes that the data is clean and can be further processed

                    //call the product services to receive the "good" data
                    //      and update it on the database (UPDATE!!!)
                    //call the appropriate service method will return the rowsaffected

                    int rowsaffected = _productServices.Product_Update(currentProduct);

                    if (rowsaffected == 0)
                    {
                        //feedback to user on no changes but no abort
                        feedBackMsg=$"{currentProduct.ProductName} (ID:{currentProduct.ProductID}) changes failed.";
                    }
                    else
                    {
                        //feedback to user on success
                        feedBackMsg=$"{currentProduct.ProductName} (ID:{currentProduct.ProductID}) changes has been saved.";
                    }

                }
            }

        }
        catch (Exception ex)
        {
            feedBackMsg=$"System Error: {ex.Message}";
        }
    }

    private void OnDiscontinue()
    {
        //clear out old messages
        feedBackMsg = "";
        errorMsgs.Clear();
        validationMessageStore.Clear();

        try
        {
            //the custom validation is dependent on how you manage your
            //  product service method
            //a) if you are NOT doing to use the incoming data to update
            //   your product before setting the Discontinued field to true
            //   then you do NOT need to do this custom validation
            //OR
            //b) you are doing to allow update and discontinue to happen on
            //      the discontinue THEN you DO need to do this custom validation
            if (editContext.Validate())
            {
                if (currentProduct.CategoryID == 0)
                {
                    validationMessageStore.Add(editContext.Field(nameof(currentProduct.CategoryID)),
                                                "You must select a category.");
                }
                if (currentProduct.SupplierID == 0)
                {
                    validationMessageStore.Add(editContext.Field(nameof(currentProduct.SupplierID)),
                                                "You must select a supplier.");
                }
                if (currentProduct.UnitPrice < 0.0m)
                {
                    validationMessageStore.Add(editContext.Field(nameof(currentProduct.UnitPrice)),
                                               "Unit price cannot be negative.");
                }

                if (editContext.GetValidationMessages().Any())
                {
                    editContext.NotifyValidationStateChanged();
                }
                else
                {
                    //call the discontinued (aka Logical Delete) service method

                    int rowsaffected = _productServices.Product_LogicalDelete(currentProduct);

                    if (rowsaffected == 0)
                    {
                        //feedback to user on no changes but no abort
                        feedBackMsg=$"{currentProduct.ProductName} (ID:{currentProduct.ProductID}) discontinued failed.";
                    }
                    else
                    {
                        //feedback to user on success
                        feedBackMsg=$"{currentProduct.ProductName} (ID:{currentProduct.ProductID}) has been discontinued.";
                    }

                }
            }

        }
        catch (Exception ex)
        {
            feedBackMsg=$"System Error: {ex.Message}";
        }
    }

    // if you are going to physically remove a record that is of importance
    //  CONSIDER prompting the user for confirmation BEFORE phyiscally removing
    //  the record
    // private void OnRemoval()
    // {
        //clear out old messages
        // feedBackMsg = "";
        // errorMsgs.Clear();
        // validationMessageStore.Clear();

        // try
        // {
            //call the removal (aka physical Delete) service method
            // int rowsaffected = _productServices.Product_PhysicalDelete(currentProduct);
            // if (rowsaffected == 0)
            // {
                //feedback to user on no changes but no abort
            //     feedBackMsg=$"{currentProduct.ProductName} (ID:{currentProduct.ProductID}) removal failed.";
            // }
            // else
            // {
                //feedback to user on success
    //             feedBackMsg=$"{currentProduct.ProductName} (ID:{currentProduct.ProductID}) has been remove from service.";
    //         }
    //     }
    //     catch (Exception ex)
    //     {
    //         feedBackMsg=$"System Error: {ex.Message}";
    //     }
    // }


    //this event will prompt the user to continue by using a javascript dialogue
    //the program needs to WAIT until the user responses
    //In this situation, the dialogue should be run in a separate task
    //NOTE: the return datatype for this instance with be changed to async Task
    private async Task OnClear()
    {
        //clear out old messages
        feedBackMsg = "";
        errorMsgs.Clear();

        //stepup and execute the prompt dialogue
        object[] messagestring = new object[]
            {"Clearing the page will lose all non-saved data. Do you wish to continue?"};
        if (await (jSRuntime.InvokeAsync<bool>("confirm",messagestring)))
        {
            //remove any old custom error messages placed in the Validation Message
            //      store
            validationMessageStore.Clear();

            //clear out the old values
            //clear the current product instance of any data
            //      (not using local variables)
            //notice that the "system" constructor is used as the entity has
            //      NO constructor code within it
            currentProduct = new Product();

            // IMPORTANT!!!!!!!!!!!!!!!!!!
            // the editContext is associated with the current product instance
            // the editContext REQUIRES to be reset to the NEW current product
            //          instance
            editContext = new EditContext(currentProduct);
        }

    }

    private async Task OnGoToSearch()
    {
        //clear out old messages
        feedBackMsg = "";
        errorMsgs.Clear();

        //stepup and execute the prompt dialogue
        object[] messagestring = new object[]
            {"Leaving the page will lose all non-saved data. Do you wish to continue?"};
        if (await (jSRuntime.InvokeAsync<bool>("confirm", messagestring)))
        {
            navigationManager.NavigateTo("categoryproducts");
        }

    }
}
