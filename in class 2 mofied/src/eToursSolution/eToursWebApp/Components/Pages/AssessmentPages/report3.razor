@page "/schedule"
<PageTitle>Excursion Schedule</PageTitle>
@rendermode InteractiveServer

@using eToursWebApp.Model

<h1>Excursion Schedule</h1>

<!--
    error display area for showing validation or system errors
    i show errors here if there were problems reading the file or parsing records
-->
@if (errorList.Count > 0)
{
    <div class="alert alert-danger">
        <p><strong>Please fix the following issues:</strong></p>
        <ul>
            @foreach (var error in errorList)
            {
                <!-- each error gets displayed as a list item -->
                <li>@error</li>
            }
        </ul>
    </div>
}

<!--
    feedback area for success messages
    display only if there is a success message to show
-->
@if (!string.IsNullOrEmpty(successMessage))
{
    <div class="alert alert-info">
        <p>@successMessage</p>
    </div>
}

<!--
    conditional display based on file existence and data availability
    i use nested if-else to show different messages for different scenarios
-->
@if (!fileExists)
{
    <!-- file does not exist at all -->
    <div class="alert alert-warning text-center">
        <p>No file has been loaded. Please check the file path.</p>
    </div>
}
else if (!fileHasData)
{
    <!-- file exists but is empty -->
    <div class="alert alert-info text-center">
        <p>The excursion file is empty. No data to display.</p>
    </div>
}
else if (excursions.Count == 0 && errorList.Count > 0)
{
    <!-- file has data but all records failed validation -->
    <div class="alert alert-warning text-center">
        <p>All records in the file had errors. No valid data to display.</p>
    </div>
}
else if (excursions.Count > 0)
{
    <!-- we have valid data to display in a table -->
    <div class="row">
        <div class="col-md-10 offset-md-1">
            <table class="table table-striped">
                <thead>
                    <tr style="background-color: #f0f0f0;">
                        <th>Name</th>
                        <th>Excursion Date</th>
                        <th>Duration (hours)</th>
                        <th>Tour Type</th>
                    </tr>
                </thead>
                <tbody>
                    <!--
                    loop through each excursion and display it as a table row
                    -->
                    @foreach (var excursion in excursions)
                    {
                        <tr>
                            <td>@excursion.Name</td>
                            <td>@excursion.ExcursionDate.ToString("MMM dd, yyyy")</td>
                            <td>@excursion.Duration</td>
                            <td>@excursion.TourType</td>
                        </tr>
                    }
                </tbody>
            </table>
        </div>
    </div>
}

<!--
    Activity 2
    create a table display for the data, see image in question for layout
    create separate messages if a) the data file does not exist and
                                b) the data file exists but is empty
-->
@code {
    // ============================================================
    // VARIABLES AND PROPERTIES
    // ============================================================

    // collection to hold the excursion objects loaded from the CSV file
    private List<Excursion> excursions = new List<Excursion>();

    // message to display on successful processing
    private string successMessage = "";

    // collection to hold error messages encountered during processing
    // i use a list here (not dictionary) because order matters for record errors
    private List<string> errorList = new List<string>();

    // boolean flags to track file state
    // these flags let me avoid using 'return' statements
    private bool fileExists = false;  // does the file exist at all?
    private bool fileHasData = false; // does the file have any content?

    // ============================================================
    // LIFECYCLE METHODS
    // ============================================================

    protected override void OnInitialized()
    {
        // the base class has a default method for OnInitialized()
        // the default method does your base setup
        // it is strongly suggested that you DO NOT remove this statement
        base.OnInitialized();

        // call the method to load excursions from the CSV file
        LoadExcursions();
    }

    // ============================================================
    // DATA LOADING METHODS
    // ============================================================

    /// <summary>
    /// loads excursion records from the CSV file
    /// uses boolean flags instead of return statements
    /// processes all records and separates good from bad
    /// </summary>
    private void LoadExcursions()
    {
        // ============================================================
        // STEP 1: CLEAR ANY PREVIOUS DATA
        // ============================================================
        // clear any previous data from the collections
        // this is important if the page reloads or gets navigated to multiple times
        excursions.Clear();
        errorList.Clear();
        successMessage = "";

        // reset the boolean flags to their default state
        fileExists = false;
        fileHasData = false;

        // ============================================================
        // STEP 2: SET THE FILE PATH
        // ============================================================
        // set the path to the CSV file to be read
        // i can change this to test different scenarios:
        string filePath = "./Data/eTourGood.csv";
        // string filePath = "./Data/eTourEmpty.csv";       // for testing empty file
        // string filePath = "./Data/eTourGoodBad.csv";     // for testing mixed good/bad records
        // string filePath = "./Data/eTourNotThere.csv";    // for testing missing file

        // ALTERNATIVE: using IWebHostEnvironment (more robust approach)
        // if i had IWebHostEnvironment injected, i could use:
        // string filePath = $@"{webHostEnvironment.ContentRootPath}/Data/eTourGood.csv";

        // ============================================================
        // STEP 3: CHECK IF FILE EXISTS
        // ============================================================
        // check if the file exists before attempting to read
        // this prevents FileNotFoundException
        // using System.IO.File.Exists() with full namespace because we can't use 'using System.IO;'
        if (System.IO.File.Exists(filePath))
        {
            // file exists! set the flag to true
            fileExists = true;
        }

        // ============================
        // EDUCATIONAL NOTE: WHY System.IO.File?
        // ============================
        // we can use File.Exists() without System.IO if we add: using System.IO;
        // but the class notes recommend using fully qualified names in Blazor
        // this makes it crystal clear which File class we're using
        // ============================

        // ============================================================
        // STEP 4: PROCEED ONLY IF FILE EXISTS
        // ============================================================
        // instead of using 'return' if file doesn't exist, i use an if block
        // this way the code only executes when the condition is true
        if (fileExists)
        {
            // ============================================================
            // STEP 5: READ ALL LINES FROM THE FILE
            // ============================================================

            // ============================================================
            // CSV READING METHODS - DIFFERENT APPROACHES
            // ============================================================

            // METHOD 1: File.ReadAllLines (CURRENTLY USED) ✓
            // --------------------------------------------------------
            // Pros: Simple, loads entire file at once, easy to check length
            // Cons: Loads entire file into memory (not ideal for huge files)
            // Best for: Small to medium CSV files (like this project)
            string[] lines = System.IO.File.ReadAllLines(filePath);


            // METHOD 2: File.ReadLines with ToArray() (COMMENTED)
            // --------------------------------------------------------
            // Pros: Lazy loading, memory efficient
            // Cons: Need to convert to array to check count
            // Best for: Large files where memory is a concern
            // var linesEnumerable = System.IO.File.ReadLines(filePath);
            // string[] lines = linesEnumerable.ToArray();


            // METHOD 3: StreamReader (COMMENTED)
            // --------------------------------------------------------
            // Pros: Maximum control, can handle encoding issues
            // Cons: More verbose, need manual cleanup
            // Best for: Large files or when you need line-by-line control
            // List<string> linesList = new List<string>();
            // using (StreamReader reader = new StreamReader(filePath))
            // {
            //     string line;
            //     while ((line = reader.ReadLine()) != null)  // read until end of file
            //     {
            //         linesList.Add(line);
            //     }
            // }
            // string[] lines = linesList.ToArray();


            // METHOD 4: File.ReadAllText with Split (COMMENTED)
            // --------------------------------------------------------
            // Pros: Single read operation
            // Cons: Need to handle different line ending types
            // Best for: When you need the entire file as one string first
            // string allText = System.IO.File.ReadAllText(filePath);
            // string[] lines = allText.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.None);


            // ============================================================
            // STEP 6: CHECK IF FILE HAS DATA
            // ============================================================
            // check if the file contains any lines
            if (lines.Length > 0)
            {
                // file has content! set the flag
                fileHasData = true;
            }

            // ============================================================
            // STEP 7: PROCESS DATA ONLY IF FILE HAS CONTENT
            // ============================================================
            // instead of 'return' if file is empty, i use another if block
            if (fileHasData)
            {
                // ============================================================
                // STEP 8: LOOP THROUGH EACH LINE AND PARSE
                // ============================================================
                // process each line in the file
                // use a counter to track which record number we are processing
                // this gives better error messages to the user
                int recordNumber = 0;

                foreach (string line in lines)
                {
                    recordNumber++;  // increment counter for each line

                    // ============================================================
                    // STEP 9: SKIP EMPTY LINES
                    // ============================================================
                    // only process lines that have content
                    // skip empty or whitespace-only lines silently
                    if (!string.IsNullOrWhiteSpace(line))
                    {
                        // ============================================================
                        // STEP 10: TRY TO PARSE EACH LINE
                        // ============================================================
                        // attempt to parse the line into an Excursion object
                        // use try-catch to handle any errors that occur during parsing
                        try
                        {
                            // use the static Parse method from Excursion class
                            // this method handles splitting the CSV and creating the object
                            Excursion excursion = Excursion.Parse(line);

                            // SUCCESS! add the valid excursion to our collection
                            excursions.Add(excursion);
                        }
                        catch (ArgumentNullException ex)
                        {
                            // ============================================================
                            // HANDLE NULL ERRORS
                            // ============================================================
                            // this happens when required fields (Name, Description) are missing
                            // i include the record number so user knows which line failed
                            errorList.Add($"Data Error: Record {recordNumber} - {ex.Message}. Data: {line}");
                        }
                        catch (ArgumentException ex)
                        {
                            // ============================================================
                            // HANDLE VALIDATION ERRORS
                            // ============================================================
                            // this happens when validation fails (date too old, negative duration, etc.)
                            errorList.Add($"Data Error: Record {recordNumber} - {ex.Message}. Data: {line}");
                        }
                        catch (FormatException ex)
                        {
                            // ============================================================
                            // HANDLE FORMAT ERRORS
                            // ============================================================
                            // this happens when the line doesn't have the correct number of fields
                            // or when data types can't be converted (e.g., "abc" instead of a number)
                            errorList.Add($"Record Format: Record {recordNumber} - {ex.Message}. Data: {line}");
                        }
                        catch (Exception ex)
                        {
                            // ============================================================
                            // HANDLE ANY OTHER ERRORS
                            // ============================================================
                            // catch any other unexpected errors
                            // get the innermost exception for the clearest message
                            Exception innerEx = GetInnerException(ex);
                            errorList.Add($"Error: Record {recordNumber} - {innerEx.Message}. Data: {line}");
                        }
                    }
                    // empty lines are silently ignored (no error added)
                }

                // ============================================================
                // STEP 11: SHOW SUCCESS MESSAGE
                // ============================================================
                // check if we loaded at least one valid excursion
                // only show success if we have data AND no errors
                if (excursions.Count > 0 && errorList.Count == 0)
                {
                    successMessage = $"Successfully loaded {excursions.Count} excursion(s).";
                }
                else if (excursions.Count > 0 && errorList.Count > 0)
                {
                    // we have some good data but also some errors
                    successMessage = $"Loaded {excursions.Count} valid excursion(s). Some records had errors (see below).";
                }
                // if excursions.Count is 0 and errorList has items,
                // it means all records failed validation
                // no success message needed - errors will display
            }
            else
            {
                // ============================================================
                // STEP 12: FILE IS EMPTY
                // ============================================================
                // file exists but contains no data
                // this message will display in the @if block at the top
                successMessage = "The excursion file is empty. No data to display.";
            }
        }
        else
        {
            // ============================================================
            // STEP 13: FILE DOES NOT EXIST
            // ============================================================
            // file does not exist at the specified path
            // add this as a system error
            errorList.Add($"The file {filePath} does not exist.");
        }

        // method ends naturally without any 'return' statements
        // the logic flow is controlled entirely by if/else blocks and boolean flags
        // this makes the code easier to read and understand
    }

    // ============================================================
    // HELPER METHODS
    // ============================================================

    /// <summary>
    /// helper method to unwrap nested exceptions
    /// finds the original/root exception that caused the error
    /// this gives us the most specific and helpful error message
    /// </summary>
    private Exception GetInnerException(Exception ex)
    {
        // some exceptions wrap other exceptions (InnerException property)
        // i loop until i find the deepest one (the real cause)
        while (ex.InnerException != null)
            ex = ex.InnerException;
        return ex;
    }
}
