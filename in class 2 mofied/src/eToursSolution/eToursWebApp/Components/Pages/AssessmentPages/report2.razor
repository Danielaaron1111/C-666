@page "/schedule"
<PageTitle>Excursion Schedule</PageTitle>
@rendermode InteractiveServer

@using eToursWebApp.Model

<h1>Excursion Schedule</h1>

@if (feedBackMsg.Length > 0)
{
    <div class="alert alert-info">
        <p>@feedBackMsg</p>
    </div>
}

@if (errorMsgs.Count > 0)
{
    <div class="alert alert-danger">
        <p>Please fix the following issues:</p>
        <ul>
            @foreach (var error in errorMsgs)
            {
                <li>@error</li>
            }
        </ul>
    </div>
}
@if (!fileExists)  // ← Check: Does file NOT exist?
{
    <div class="alert alert-warning text-center">
        <p>No file has been loaded. Please check the file path.</p>
    </div>
}
else if (excursions.Count == 0)  // ← Check: Is it empty?
{
    <div class="alert alert-info text-center">
        <p>The excursion file is empty. No data to display.</p>
    </div>

}
else
{

    <div class="row">
        <div class="col-md-10 offset-md-1">
            <table class="table table-striped">
                <thead>
                    <tr>
                        <th>Name</th>
                        <th>Excursion Date</th>
                        <th>Duration (hours)</th>
                        <th>Tour Type</th>
                    </tr>
                </thead>
                <tbody>
                    @foreach (var excursion in excursions)
                    {
                        <tr>
                            <td>@excursion.Name</td>
                            <td>@excursion.ExcursionDate.ToString("MMM dd, yyyy")</td>
                            <td>@excursion.Duration</td>
                            <td>@excursion.TourType</td>
                        </tr>
                    }
                </tbody>
            </table>
        </div>
    </div>
}

<!--
    Activity 2
    create a table display for the data, see image in question for layout
    create separate messages if a) the data file does not exist and
                                b) the data file exists but is empty


@*                      Name = name;
            ExcursionDate = excursiondate;
            Duration = duration;
            TourType = tourtype; *@
-->
@code {


    private string feedBackMsg = "";
    private List<string> errorMsgs = new List<string>();

    // Collection to store all valid excursion records loaded from file
    private List<Excursion> excursions = new List<Excursion>();

    // Flag to track whether the CSV file exists or not
    private bool fileExists = false;  // Start: assume file doesn't exist

    protected override void OnInitialized()
    {
        base.OnInitialized();

        // Define which CSV file to load
        string filename = @"./Data/eTourGood.csv";
        // string filename = @"./Data/eTourEmpty.csv";
        //string filename = @"./Data/eTourGoodBad.csv";
        // string filename = @"./Data/eTourNotThere.csv";

        //Activity 2

        //write the code to
        //  a) read the file
        //  b) place the records in a collection to display in the table above
        //  c) user friendly error handling is required.
        //  d) all records in the file must be handled, processed as good or bad

        // ===========================================
        // STEP 1: CHECK IF FILE EXISTS
        // ===========================================
        // Before attempting to read, verify the file actually exists
        // This prevents FileNotFoundException

        if (!File.Exists(filename))
        {
            // File doesn't exist - set flag and show error
            fileExists = false;
            errorMsgs.Add("System Error: File does not exist.");
            // Instead of 'return', we skip to the end by not executing further code
        }
        else  // ← File EXISTS, proceed with reading
        {
            // Set flag to indicate file was found
            fileExists = true;


            // ============================================================
            // CSV READING METHODS - DIFFERENT APPROACHES
            // ============================================================

            // METHOD 1: File.ReadAllLines (CURRENTLY USED) ✓
            // --------------------------------------------------------
            // Pros: Simple, loads entire file into string array at once
            // Cons: Loads entire file into memory (not ideal for huge files)
            // Best for: Small to medium CSV files (like this project)
            string[] lines = File.ReadAllLines(filename);


            // METHOD 2: File.ReadLines (LAZY LOADING - COMMENTED)
            // --------------------------------------------------------
            // Pros: Memory efficient - reads one line at a time (IEnumerable)
            // Cons: Can't check .Length before iterating
            // Best for: Large files where memory is a concern
            // var lines = File.ReadLines(filename);
            // int lineCount = 0;
            // foreach (string line in lines)
            // {
            //     lineCount++;
            //     // Process each line here...
            // }


            // METHOD 3: StreamReader with ReadLine (COMMENTED)
            // --------------------------------------------------------
            // Pros: Maximum control, can handle encoding issues, read line-by-line
            // Cons: More verbose, need to manage using block
            // Best for: Large files or when you need custom processing per line
            // List<string> linesList = new List<string>();
            // using (StreamReader reader = new StreamReader(filename))
            // {
            //     string line;
            //     while ((line = reader.ReadLine()) != null)  // Read until end of file
            //     {
            //         linesList.Add(line);
            //     }
            // }
            // string[] lines = linesList.ToArray();


            // METHOD 4: TextFieldParser (PROPER CSV PARSING - COMMENTED)
            // --------------------------------------------------------
            // Pros: Handles complex CSV (quoted fields, embedded commas)
            // Cons: Requires Microsoft.VisualBasic.FileIO reference
            // Best for: Complex CSV files with quoted fields
            // NOTE: Requires adding: @using Microsoft.VisualBasic.FileIO
            // List<string> linesList = new List<string>();
            // using (TextFieldParser parser = new TextFieldParser(filename))
            // {
            //     parser.TextFieldType = FieldType.Delimited;
            //     parser.SetDelimiters(",");
            //     while (!parser.EndOfData)
            //     {
            //         string[] fields = parser.ReadFields();
            //         // Rejoin fields back into CSV line for our Parse method
            //         linesList.Add(string.Join(",", fields));
            //     }
            // }
            // string[] lines = linesList.ToArray();


            // ===========================================
            // STEP 2: CHECK IF FILE IS EMPTY
            // ===========================================
            if (lines.Length == 0)
            {
                // File exists but contains no data
                feedBackMsg = "The excursion file is empty. No data to display.";
                // Instead of 'return', we just skip the processing below
            }
            else  // ← File has data, proceed with parsing
            {
                // ===========================================
                // STEP 3: PARSE EACH LINE
                // ===========================================
                // Loop through each line in the file
                // Try to parse it into an Excursion object
                // Handle both valid and invalid records

                foreach (string line in lines)
                {
                    try
                    {
                        // Attempt to parse the CSV line using the static Parse method
                        // This method handles splitting the CSV and creating the Excursion object
                        Excursion excursion = Excursion.Parse(line);

                        // SUCCESS! Add the valid excursion to our collection
                        excursions.Add(excursion);
                    }
                    catch (Exception ex)
                    {
                        // FAILED! This line had invalid data
                        // Get the root cause of the error
                        Exception innerEx = GetInnerException(ex);

                        // Add user-friendly error message showing which record failed
                        errorMsgs.Add($"Error on record: {innerEx.Message}");

                        // Note: We DON'T use 'return' here
                        // We want to continue processing other lines even if one fails
                        // This ensures all records are attempted (requirement d)
                    }
                }

                // ===========================================
                // STEP 4: SHOW SUCCESS MESSAGE
                // ===========================================
                // Only show success if we loaded at least one valid excursion
                if (excursions.Count > 0)
                {
                    feedBackMsg = $"Successfully loaded {excursions.Count} excursion(s).";
                }
                // If excursions.Count is 0 and errorMsgs has items,
                // it means all records failed validation
                // No 'else' needed - error messages will display automatically
            }
        }
        // Method ends naturally without any 'return' statements
        // The logic flow is controlled by if/else blocks instead
    }



    private Exception GetInnerException(Exception ex)
    {
        // Helper method to unwrap nested exceptions
        // Finds the original/root exception that caused the error
        // This gives us the most specific error message
        while (ex.InnerException != null)
            ex = ex.InnerException;
        return ex;
    }
}
